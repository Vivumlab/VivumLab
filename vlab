#!/usr/bin/env ruby
require 'rubygems'
require 'bundler'
require 'securerandom'
require 'pry'
Bundler.require(:default)

# This file contains just enough code to bootstrap the CLI.
# Bias towards putting actual tasks in namespaced files under
# tasks/. ie: tasks/sanitychecks.rb
# Namespaced Task classes must be part of module Vlab and inherit from
# SubCommandBase

module Vlab
  class SubCommandBase < Thor
    require './tasks/utils.rb'
    include Utils
    def self.banner(command, namespace = nil, subcommand = false)
      "#{basename} #{subcommand_prefix} #{command.usage}"
    end

    def self.subcommand_prefix
      self.name.gsub(%r{.*::}, '').gsub(%r{^[A-Z]}) { |match| match[0].downcase }.gsub(%r{[A-Z]}) { |match| "-#{match[0].downcase}" }
    end

    no_commands {
      def invoke_subcommand(klass, task, *params)
        fully_qualified_class_name = "::Vlab::#{klass}"
        classConst = Object.const_get( fully_qualified_class_name )
        classConst.new.invoke(task, params)
      end
    }
  end

  class CLI < Thor
    # Next line loads all ruby files in tasks/**/*.rb
    Dir["./tasks/**/*.rb"].each {|file| require file }
    # If the included files are classes inheriting from SubCommandBase
    # dynamically add them to the available tasks list.
    Vlab.constants.select {|c| (Vlab.const_get(c).is_a? Class) && (Vlab.const_get(c.to_s).superclass.to_s == "Vlab::SubCommandBase")}.each do |klass|
      desc klass.to_s, "Use vlab #{klass} for more information"
      subcommand "#{klass.to_s}", Kernel.const_get("Vlab::#{klass.to_s}")
    end

    # This method ensures that if we have an error, the resulting return code
    # in the shell is not 0.
    def self.exit_on_failure?
      true
    end
  end
end

# Kick off the actual cli app.
Vlab::CLI.start
